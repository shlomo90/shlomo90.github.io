

ngx_http_init_connection (ls->handler)
            | * args = ngx_connection_t
            | * update "c->data"
            |   - create ngx_http_connection_t structure and assign it to "c->data".
            | * update "c->log", c->read->handler, c->write->handler
            |   - c->read->handler = ngx_http_wait_request_handler
            |   - c->write->handler = ngx_http_empty_handler
            |   - if http2, c->read->handler = ngx_http_v2_init
            |   - if ssl, c->read->handler = ngx_http_ssl_handshake
            |
            |
            * (wait the event...)

ngx_http_ssl_handshake
       +--->| ! handler state
      /     |   - c->read->handler = ngx_http_ssl_handshake
    E|      |   - c->write->handler = ngx_http_empty_handler
    A|      |
    G|      |
    A|      | * Do recv() to check SSL protocol versions
    I|      | * Do ngx_ssl_create_connection
    N|      |   - This connection is for SSL.
     |      * * Do ngx_ssl_handshake (OPENSSL Internal handshake starts)
     \     /|   - after successfully handshake done, "c->ssl->handshaked" is set.
      +---+ |
            |
            | * handler changes
            |   - c->read->handler = ngx_http_wait_request_handler
            |   - c->write->handler = ngx_http_empty_handler /* STUB */
            |
            | * Do ngx_http_wait_request_handler
            |
            V


ngx_http_wait_request_handler
            | ! handler state
            |   - c->read->handler = ngx_http_wait_request_handler
            |   - c->write->handler = ngx_http_empty_handler
            |
            |
            | * Create buffer "c->buffer"
            | * Receive data from socket (Maybe Request Headers)
            * * Do "ngx_http_create_request" (Create ngx_http_request_t structure!)
            |\
            | | * r structure allocated
            | | * r->main_conf, r->srv_conf, r->loc_conf assigned
            | |   - This will be 
            | | * r->header_in = hc->busy[0] or c->buffer
            | |   - hc->busy is for HTTP pipelining.
            | | * r->headers_in.content_length_n, ... initialized
            |/ 
            |
            | * c->read->handler = ngx_http_process_request_line
            | * Do "ngx_http_process_request_line"
            V

ngx_http_process_request_line
    +------>| ! handler state
   /        |   - c->read->handler = ngx_http_process_request_line
  |         |   - c->write->handler = ngx_http_empty_handler
  |         |
  |         | * Do "ngx_http_read_request_header"
  |         *   - Just Read data from socket and update "r->header_in"
 / \ EAGAIN/|
 |  +-----+ |O
 |          |K
 |          |
 |          |
 |          * * Do "ngx_http_parse_request_line"
 | EAGAIN  /|   - Read Just one Request Header line.
 +--------+ |   - If result is EGAIN, and header_in buffer is full,
           O|     Do ngx_http_alloc_large_header_buffer.
           K|
            | * Do ngx_http_process_request_uri
            | * Do ngx_http_validate_host
            | * Do ngx_http_set_virtual_server
            | * Init "r->headers_in.headers" list.
            | * Handler changes
            |   - c->read->handler = ngx_http_process_request_headers
            | * Do ngx_http_process_request_headers
            V

ngx_http_process_request_headers
            | ! Handler State
            |   - c->read->handler = ngx_http_process_request_headers
            |   - c->write->handler = ngx_http_empty_handler
            |
      +---->| (!: rev->handler is "ngx_http_process_request_headers")
     /      |
 rc =|      | * ngx_http_read_request_header
    E|      |   - recv data from socket and update "r->header_in->last"
    A|      | * rc = ngx_http_parse_header_line
    G|      |   - In this function, update "r->header_name_end", "r->header_start", "r->header_end"
    A|      |     "r->header_hash"
    I|      |  rc == PARSE_HEADER_DONE
    N|      *-----------------------------------------+
     /\    /| * update "r->request_length"            | * update "r->request_length"
    /  +--+ | * Get a elem from r->headers_in.headers | * update "r->http_state"
    | rc = O| * update "h->hash", "h->key", "h->value"| * do "ngx_http_process_request_header"
    |      K|   - "h" means header.                   | * do "ngx_http_process_request(r)"
    |       | * find hash "r->header_hash"            |      (Next step)
    |       |   - do hash handler (headers_in)        |
    |       |   - See also "ngx_http_headers_in" var  |
     \     /                                          |
      +---+                                          / 
            +---------------------------------------+
            |
            V

ngx_http_process_request
            |
            | * Do SSL relative logic. (SSL Detection, SSL Verify, etc.)
            | * Handler change
            |   - c->read->handler = ngx_http_request_handler
            |   - c->write->handler = ngx_http_request_handler
            |   - r->read_event_handler = ngx_http_block_reading
            |
            | * Do ngx_http_handler (Entry point)
            | * Do ngx_http_run_posted_requests
            |
            V


buffer

start           pos                  last                    end                       
+---------------+--------------------+-----------------------+
|               |                    |                       |
| Parsed Data   | Data to be parsed  | Empty buffer space    |
|               |                    |                       |
+---------------+--------------------+-----------------------+

start <-> pos
- currently nginx read (parsing)
start <-> last
- received data from socket
start <-> end
- total buffer size (fixed ususally)
pos <-> last
- the length of data to be parsed more
last <-> end
- It's empty space in buffer.

Nginx uses buffer system in many cases like r->header_in, chain, etc.
This buffer's structure is named "ngx_buf_t".




ngx_http_core_content_phase
    call r->content_handler (ngx_http_proxy_handler)


ngx_http_add_location
    - created clcf 


cf->ctx->loc_conf[ngx_http_core_module.ctx_index]->locations  is queue (q)
    1. alloc ngx_http_location_queue_t (lq)
    2. init lq->list
    2. insert lq tail to q


ngx_http_init_listening
    alloc hport.
    ls->servers = hport


    ls->servers = 



ngx_http_block (cf, cmcf, cmcf->ports)
    cmcf->ports is added ngx_http_add_listen

    each cmcf->ports "port" 's default_server = 


1. listen directive
    - do ngx_http_add_listen(cf, cscf, lsopt)
      - cscf is passed the default "conf"
    
2. ngx_http_add_listen
    - create ports array.
    - each port do ngx_http_add_addreses(cf, cscf, &port[i], lsopt)
    - and final step is do ngx_http_add_address

3. ngx_http_add_addresses
    - each port's addrs "addr"'s opt has the default_server

4. ngx_http_add_address(cf, cscf, port, lsopt)
    - each port's addrs "addr" initialized
    - addr has the default_server = cscf.

---------------------------



scrum
    - evolving versions
    - scrum test board
    daily scrum meeting.
sprint
    - work sort cycle.
    - team 
    - we'll have 

        product backlog 

